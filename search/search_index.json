{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Zoglin","text":"<p>The result of bringing MCFunction in to the overworld...</p> <p>Zoglin is a little language that compiles into a datapack. It focuses on creating simple, clean abstractions for datapack concepts, to allow the user to craft the datapack they desire.</p> <p>Zoglin is primarily targeted to technical datapack creators. Zoglin aims to be intuitive to an experienced datapack creator, albeit providing syntax and features similar to those found in more traditional programming languages.</p> Zoglin (.zog)MCFunction (.mcfunction) main.zog<pre><code>namespace example\n\nmodule foo {\n  fn bar() {\n    # Set 'baz' to 'Hello, World!'\n    baz = \"Hello, World!\"\n\n    # Set 'qux' to 123\n    $qux = 123\n\n    # Run the tellraw command\n    tellraw @a \"Lorem ipsum dolor sit amet\"\n  }\n}\n</code></pre> example:foo/bar<pre><code># Set 'baz' to 'Hello, World!'\ndata modify storage example:foo/bar baz set value \"Hello, World!\"\n\n# Set 'qux' to 123\nscoreboard players set $qux example.foo.bar 123\n\n# Run the tellraw command\ntellraw @a \"Lorem ipsum dolor sit amet\"\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#why-the-name-zoglin","title":"Why the name Zoglin?","text":"<p>In Minecraft, the command bar sorts functions in the autocomplete in alphabetical order. This has lead to a convention of datapack developers putting their private functions in a namespace marked as <code>zzz</code> or <code>z_priv</code>. We didn't like this convention, but wished to have our generated functions be listed at the bottom.</p> <p>So we picked a name that started with a <code>z</code>, to achieve this without using an ugly namespace. The name Zoglin was unused in this niche, and started with a <code>z</code> so we ended up choosing it.</p>"},{"location":"faq/#why-use-zoglin-why-not-use-another-precompiler","title":"Why use Zoglin? Why not use another precompiler?","text":"<p>Zoglin caters towards making technical datapacks. It has a focus on project organisation, compilation transparency and flexibility.</p> <p>Zoglin provides powerful core features for managing project structure. Namespaces and modules allow developers to express the folder structure of their datapack, whilst still maintaining the flexibility of being able to define a datapack in a single file, or split it up as they choose.</p> <p>As well, Zoglin aims to provide clean abstractions above MCFunction, that compile in a way that is transparent to the developer. This concept of compilation transparency is a fundamental design principle guiding the development of Zoglin, as we understand that technical datapacks often require using MCFunction in unintended ways.</p>"},{"location":"faq/#what-is-compilation-transparency","title":"What is Compilation Transparency?","text":"<p>Compilation Transparency is the concept that language features and elements must compile in a clear and predictable way for the programmer.</p> <p>This is a guiding design principle behind many of Zoglin's core features.</p> <p>For example, let's take functions. A function defined in Zoglin will always predictably generate in a folder with the same name as it's module, and will always generate under the namespace it was defined in.</p> <p>Commands within a function can be written just as they could be written in MCFunction.</p> <p>Variables are always namespaced to the function they were declared in, making them easy to access from within commands, as predicting their path is as easy as adding together the namespace, modules, and name of the function.</p> <p>This transparency allows developers to easily be able to interoperate with the generated code directly from other, non-Zoglin datapacks, as well as allowing the developer to better optimise and control the generated code.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will take you through making your first datapack with Zoglin.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<ol> <li>Download Zoglin from our Github Releases</li> <li>Extract the file, and put the Zoglin binary in your PATH.</li> </ol>"},{"location":"getting-started/#example-diamond-jump","title":"Example: Diamond Jump","text":"<p>In this example, we will create a datapack that gives you a diamond whenever you jump. This example is purposefully very simple.</p>"},{"location":"getting-started/#create-the-project","title":"Create the Project","text":"<p>Navigate to your projects folder in your command line / terminal.</p> <p>To create a Zoglin project, you can use the <code>init</code> command: <pre><code>$ zoglin init &lt;name&gt;\n</code></pre></p> <p>We will be calling this project <code>diamond_jump</code> <pre><code>$ zoglin init diamond_jump\n</code></pre></p> <p>This will create a folder named <code>diamond_jump</code>, containing a <code>main.zog</code> file. main.zog<pre><code>namespace diamond_jump {\n  fn tick() {\n\n  }\n\n  fn load() {\n    tellraw @a \"Loaded diamond_jump\"\n  }\n}\n</code></pre> You'll notice that the default project has a <code>tick</code> and a <code>load</code> function.</p> <p>Zoglin automatically adds functions named <code>tick</code> or <code>load</code> to their corresponding function tag, as long as they are defined in the root of a namespace.</p>"},{"location":"getting-started/#lets-get-it-coded","title":"Let's get it Coded!","text":"<p>Lets start by adding a scoreboard objective to <code>load</code>. Zoglin does provide helpers to add these, but for this example we will just use a command.</p> <p>main.zog<pre><code>namespace diamond_jump {\n  fn tick() {}\n\n  fn load() {\n    tellraw @a \"Loaded diamond_jump\"\n\n    # Add a jump tracker objective\n    scoreboard objectives add diamond_jump.jumps minecraft.custom:minecraft.jump\n  }\n}\n</code></pre> This will keep track of whenever a player jumps.</p> <p>Next, we'll define a function to give us a diamond. We'll call it <code>grant</code>. main.zog<pre><code>namespace diamond_jump {\n  fn tick() {}\n\n  fn load() {\n    tellraw @a \"Loaded diamond_jump\"\n\n    # Add a jump tracker objective\n    scoreboard objectives add diamond_jump.jumps minecraft.custom:minecraft.jump\n  }\n\n  # Define the `grant` function\n  fn grant() {\n    scoreboard players reset @s diamond_jump.jumps\n    give @s minecraft:diamond\n  }\n}\n</code></pre> This is a very simple function, containing only two commands.</p> <p>In Zoglin, commands are first-class citizens, meaning they can be written out in a function, just as you would in a datapack.</p> <p>Now, in the <code>tick</code> function, we will check for players with the necessary score, and run the <code>grant</code> function as them. main.zog<pre><code>namespace diamond_jump {\n  fn tick() {\n    execute as @a[scores={diamond_jump.jumps=1..}] run function diamond_jump:grant\n  }\n\n  fn load() {\n    tellraw @a \"Loaded diamond_jump\"\n\n    # Add a jump tracker objective\n    scoreboard objectives add diamond_jump.jumps minecraft.custom:minecraft.jump\n  }\n\n  # Define the `grant` function\n  fn grant() {\n    scoreboard players reset @s diamond_jump.jumps\n    give @s minecraft:diamond\n  }\n}\n</code></pre></p> <p>Now, build the project, and try it out in game.</p>"},{"location":"getting-started/#building-watching","title":"Building / Watching","text":"<p>To build your Zoglin project, run: <pre><code>$ zoglin build\n</code></pre> Make sure you are in your project's directory.</p> <p>You will likely want to use the watch command, however, as that will watch your project for changes and automatically re-build. <pre><code>$ zoglin watch\n</code></pre></p>"},{"location":"getting-started/#example-sum-an-array","title":"Example: Sum an Array","text":"<p>Next we will create a project that will allow you to sum all of the numbers in a given array. This example demonstrates some of the more powerful features of Zoglin.</p>"},{"location":"getting-started/#create-the-project_1","title":"Create the Project","text":"<p>Let's create another project. Open the terminal to your projects folder and run: <pre><code>$ zoglin init sum\n</code></pre></p>"},{"location":"getting-started/#lets-get-it-coded_1","title":"Let's get it Coded!","text":"<p>We don't need the <code>tick</code> function for this example, so you can remove it from the file.</p> <p>Let's define the function <code>sum_array</code>. It takes one argument, <code>array</code>. This is a storage variable, meaning that it is stored in data storage.</p> <p>Let's start by assigning <code>0</code> to the variable <code>$output</code>. main.zog<pre><code>namespace sum {\n  fn load() {\n    tellraw @a \"Loaded sum\"\n  }\n\n  fn sum_array(array) {\n    $output = 0\n  }\n}\n</code></pre></p> <p>Notice, unlike the <code>array</code> variable, <code>$output</code> has a dollar (<code>$</code>) prefix. This makes it a scoreboard variable, meaning that it is stored on a scoreboard objective. It only accepts integer values.</p> <p>Next, let's iterate the array. We can use the <code>while</code> loop for that. Add the value from the front of the array to <code>$output</code>, then remove that value. When all values are removed, <code>array</code> will have a size of <code>0</code>, and the loop will end.</p> main.zog<pre><code>namespace sum {\n  fn load() {\n    tellraw @a \"Loaded sum\"\n  }\n\n  fn sum_array(array) {\n    $output = 0\n\n    while array {\n      $output = $output + array[0]\n      data remove storage sum:sum_array array[0]\n    }\n\n    return $output\n  }\n}\n</code></pre> <p>Now, let's try it out! In <code>load</code>, call the function with an array, and store the result in <code>$count</code>. Let's replace the loaded message tellraw with one to print out the result.</p> main.zog<pre><code>namespace sum {\n  fn load() {\n    $count = sum_array([1, 2, 3, 4, 5])\n    tellraw @a {\"score\":{\"name\":\"$count\",\"objective\":\"sum.load\"}}\n  }\n\n  fn sum_array(array) {\n    $output = 0\n\n    while array {\n      $output = $output + array[0]\n      data remove storage sum:sum_array array[0]\n    }\n\n    return $output\n  }\n}\n</code></pre> <p>Now build the project, and try it out in game. On a <code>/reload</code>, you should see the number <code>15</code> printed in the chat.</p>"},{"location":"zoglin/compile-time/","title":"Compile time","text":""},{"location":"zoglin/functions/","title":"Functions","text":"<p>Each function defined in Zoglin represents a <code>.mcfunction</code> file in the resulting datapack. They must be a child of a namespace, and can be nested within any amount of modules.</p>"},{"location":"zoglin/functions/#definition","title":"Definition","text":"<p>Functions are defined with the <code>fn</code> keyword, followed by an identifier, then a list of arguments in parentheses.</p> <p>main.zog<pre><code>namespace code\n\n# No arguments\nfn foo() {\n  ...\n}\n\n# Storage, scoreboard and macro arguments\nfn bar(a, $b, %c) {\n  ...\n}\n</code></pre> Functions arguments can be any of the variable types, except compile-time. Compile-time variables can only be used with compile-time functions.</p> <p>See variables for more explanation of argument types.</p>"},{"location":"zoglin/functions/#body","title":"Body","text":"<p>The body of a function can contain expressions, commands, function calls, and control flow statements such as <code>if</code> or <code>while</code>.</p> <p>main.zog<pre><code>namespace code\n\nfn baz($iter, message) {\n  while $iter &gt; 0 {\n    $iter -= 1\n    &amp;print(message)\n  }\n}\n</code></pre> The statements page explains the different statements allowed inside a function body.</p>"},{"location":"zoglin/functions/#return","title":"Return","text":"<p>Functions can return using a storage variable, a scoreboard variable, or by using the vanilla return system.</p> <p>To return a value, one can use the <code>return</code> keyword.</p> <p>Functions return to storage by default. For example, the following function will return the string <code>\"Hello, World!\"</code></p> Zoglin (.zog)MCFunction (.mcfunction) main.zog<pre><code>namespace code\n\nfn hello_world() {\n  return \"Hello, World!\"\n}\n</code></pre> hello_world.mcfunction<pre><code># Sets the special return storage variable to \"Hello, World!\"\ndata modify storage code:hello_world return set value \"Hello, World!\"\n</code></pre> <p>To return a scoreboard or vanilla return value, the function name must be prefixed by a <code>$</code> or <code>%</code> respectively.</p> Zoglin (.zog)MCFunction (.mcfunction) main.zog<pre><code># Returns a scoreboard variable\nfn $add($a, $b) {\n  return $a + $b\n}\n\n# Returns using the vanilla return\nfn %multiply($a, $b) {\n  return $a * $b\n}\n</code></pre> add.mcfunction<pre><code># Sets the $return special variable\nscoreboard players operation $return code.add = $a code.add\nscoreboard players operation $return code.add += $b code.add\n</code></pre> multiply.mcfunction<pre><code># Uses return run to return the result of the operation\nscoreboard players operation $var_0 zoglin.internal.vars = $a code.add\nreturn run scoreboard players operation $var_0 zoglin.internal.vars += $b code.add\n</code></pre>"},{"location":"zoglin/functions/#manual-returns","title":"Manual Returns","text":"<p>Sometimes it is convenient, for optimisation, to use a command to return a value instead of using the return keyword.</p> <p>To do so, write a command that assigns to the <code>return</code> variable. main.zog<pre><code>namespace code\n\n# Manually return a storage variable\nfn storage_example() {\n  data modify storage code:storage_example return set value \"Example value\"\n}\n\n# Manually return a scoreboard variable\nfn $scoreboard_example() {\n  scoreboard players set $return code.scoreboard_example set value 123\n}\n\n# Manually return with /return\nfn %vanilla_example() {\n  # Use the command literal syntax to use the vanilla return\n  /return 123\n}\n</code></pre></p>"},{"location":"zoglin/functions/#function-calls","title":"Function Calls","text":"<p>To call a function, Zoglin provides the function call syntax. Function calls are represented as a Resource Location of the function, followed by parentheses. These parentheses can hold a list of argument expressions, which get passed to the function by assigning variables before the function is called.</p> Zoglin (.zog)MCFunction (.mcfunction) main.zog<pre><code>namespace code\n\nfn example() {\n  # Call a function in a submodule\n  submodule/foo()\n\n  # Assign to a variable\n  $x = $add(1, 2)\n\n  # Use within expressions\n  $y = 10 * $add(2, 3)\n}\n\nfn $add(a, b) {\n  return a + b\n}\n\nmodule submodule {\n  fn foo () {\n    tellraw @a \"Foo!\"\n  }\n}\n</code></pre> example.mcfunction<pre><code># Call a function in a submodule\nfunction code:submodule/foo\n\n# Assign to a variable\nscoreboard players set $a code.add 1\nscoreboard players set $b code.add 2\nfunction code:add\nscoreboard players operation $x code.example = $return code.add\n\n# Use within expressions\nscoreboard players set $y code.example 10\nscoreboard players set $a code.add 2\nscoreboard players set $b code.add 3\nfunction code:add\nscoreboard players operation $y code.example *= $return code.add\n</code></pre> add.mcfunction<pre><code>scoreboard players operation $return code.add = $a code.add\nscoreboard players operation $return code.add += $b code.add\n</code></pre> submodule/foo.mcfunction<pre><code>tellraw @a \"Foo!\"\n</code></pre> <p>Recursively calling a function</p> <p>Zoglin allows you to call a function from within itself, using the function call syntax. However, this can cause some troubles as Zoglin does not use a stack for function arguments.</p> <p>Calling a function from within itself, that has arguments, will override whatever arguments were set on first call.</p> main.zog<pre><code>namespace code\n\nfn example(x) {\n  # x is currently 3\n\n  if x != 1 { example(1) }\n\n  # x is now 1\n}\n</code></pre> <p>For this reason, we would recommend not calling a function from within itself, or from within functions it calls.</p> <p>We recommend using the while loop for iteration.</p>"},{"location":"zoglin/project-structure/","title":"Project Structure","text":""},{"location":"zoglin/project-structure/#namespaces","title":"Namespaces","text":"<p>Namespaces are top-level elements of Zoglin, and represent a namespace in MCFunction.</p> <p>All subsequent elements in Zoglin are children of namespaces.</p>"},{"location":"zoglin/project-structure/#block-syntax","title":"Block Syntax","text":"<pre><code>namespace example {\n  ...\n}\n</code></pre>"},{"location":"zoglin/project-structure/#block-less-syntax","title":"Block-less Syntax","text":"<pre><code>namespace example\n# Code here is in example\n...\n\nnamespace example2\n# Code here is in example2\n...\n</code></pre>"},{"location":"zoglin/project-structure/#modules","title":"Modules","text":"<p>Modules represent a folder in the generated datapack. They can be nested within other modules.</p> <pre><code>module foo {\n  ...\n\n  # Modules can be nested\n  module bar {\n    ...\n  }\n}\n</code></pre>"},{"location":"zoglin/resource-locations/","title":"Resource Locations","text":"<p>Resource Locations represent the path of a resource in Zoglin. These behave similarly to the Resource Locations in vanilla datapacks, except for a few changes to make using them slightly more streamlined.</p>"},{"location":"zoglin/resource-locations/#namespace","title":"Namespace","text":"<p>The namespace in a Resource Location is referenced by writing the name of the namespace, followed by a colon (<code>:</code>).</p> <p>For example, in the Resource Location <code>foo:bar</code>, the namespace is <code>foo</code>.</p> <p>The name before the colon can be omitted to infer the current namespace.</p> <p>For example, <code>:bar</code> is equivalent to the <code>foo:bar</code> from before. <pre><code>[foo]:bar/baz/qux\n ^ namespace\n</code></pre></p>"},{"location":"zoglin/resource-locations/#path","title":"Path","text":"<p>The path in a Resource Location represents the path to a resource within a given namespace.</p> <p>For example, in the Resource Location <code>foo:bar/baz</code>, the path is <code>bar/baz</code>.</p> <p>Omitting a namespace altogether means that the Resource Location infers the namespace and current module. <pre><code>foo:[bar/baz/qux]\n     ^ path\n</code></pre></p>"},{"location":"zoglin/resource-locations/#target","title":"Target","text":"<p>The target is the final element of a Resource Location path. It is primarily used by variables, and represents the name of the variable, whereas the rest of the path represents the location.</p> <p>For example, the variable <code>foo:bar/baz</code> would be equivalent to the storage <code>foo:bar baz</code>. <pre><code>foo:bar/baz/[qux]\n             ^ target\n</code></pre></p>"},{"location":"zoglin/resource-locations/#example","title":"Example","text":"<p>The following example shows different Resource Location formats, which all refer to the same path (<code>foo:bar/baz/qux</code>).</p> main.zog<pre><code>namespace foo\n\nmodule bar {\n  fn baz() {\n    # Full path\n    foo:bar/baz/qux\n\n    # Inferred namespace\n    :bar/baz/qux\n\n    # Inferred namespace + module\n    ~/baz/qux\n\n    # Inferred namespace + module + function\n    qux\n  }\n}\n</code></pre>"},{"location":"zoglin/resources/","title":"Resources and Assets","text":"<p>Resources represent non-mcfunction resources within a datapack, such as JSON files.</p> <p>Resources are defined using the <code>res</code> keyword, followed by a resource type, which determines which sub-folder that resource appears in (e.g. <code>loot_table</code>, <code>advancement</code>).</p>"},{"location":"zoglin/resources/#json","title":"JSON","text":"<p>For JSON resources, after the resource type, a name can be specified, followed then by a JSON block.</p> <p>The JSON block is compatible with JSON5, which will be converted to plain JSON at compile time.</p> <p>Example: <pre><code>namespace example \n\nmodule api {\n  # Generates a resource at data/example/predicates/api/is_sneaking.json\n  res predicate is_sneaking {\n    [...]\n  }\n}\n</code></pre></p> <p>If the JSON contains an object at top-level, the braces can be ignored for the blocks own braces instead.</p> <p>Example: <pre><code>res tags/blocks air_types {\n  values: [\n    'minecraft:air', 'minecraft:cave_air',\n    'minecraft:void_air'\n  ]\n}\n</code></pre></p>"},{"location":"zoglin/resources/#other-files","title":"Other files","text":"<p>For file based resources, such as NBT files, a file path is specified as a string, after the resource type.</p> <p>The file path supports globbing, for passing through multiple files. It is relative to the current file.</p> <p>Example: <pre><code># This copies the file \"nbt/structure.nbt\" to\n# data/namespace/structures/airship.nbt\nres structures \"nbt/structure.nbt\"\n\n# This copies all nbt files in nbt/airships to\n# data/namespace/structures/\nres structures \"nbt/airships/*.nbt\"\n\n# This copies the laboratories folder to\n# data/namespace/structures/laboratories\nres structures \"nbt/laboratories\"\n</code></pre></p>"},{"location":"zoglin/resources/#assets","title":"Assets","text":"<p>Assets represent files in a resourcepack. They are defined in the exact same way as resources, but use the <code>asset</code> keyword instead.</p> <pre><code>namespace example\n\nasset models/item my_model {\n  parent: \"minecraft:item/generated\",\n  textures: {\n    layer0: \"example:my_texture\"\n  }\n}\n\nassert textures/item \"assets/items/my_texture.png\"\n</code></pre>"},{"location":"zoglin/statements/","title":"Statements","text":"<p>Statements are the contents of a function body, and compile in to lines of MCFunction code.</p>"},{"location":"zoglin/statements/#commands","title":"Commands","text":"<p>In Zoglin, most commands can be written directly as they would be in MCFunction. They compile directly to commands within the function.</p> main.zog<pre><code>namespace example\n\nfn foo() {\n  data modify storage example:foo/bar set value \"Hello, World!\"\n}\n</code></pre> <p>There are a couple of exceptions, such as with <code>return</code>, where the command might conflict with a keyword.</p> <p>To resolve such cases, a command literal syntax also exists, which allows commands to be written inside backticks. main.zog<pre><code>namespace example\n\nfn foo() {\n  `return 123`\n}\n</code></pre></p> <p>The backticks syntax also has the benefit of allowing commands to span multiple lines. main.zog<pre><code>namespace example\n\nfn foo() {\n  `data modify storage foo:bar baz set value [\n    1, 2, 3,\n    4, 5, 6,\n    7, 8, 9\n  ]`\n}\n</code></pre></p> <p>Any additional whitespace is stripped from within the command. Newlines are either stripped or replaced with space.</p> <p>Spaces, however, are maintained within strings inside the command. main.zog<pre><code>namespace example\n\nfn foo() {\n  `data modify storage foo:bar baz set value \"This whitespace is    maintained!\"`\n}\n</code></pre></p>"},{"location":"zoglin/statements/#inline-expressions","title":"Inline Expressions","text":"<p>Commands can also have inline expressions, allowing for dynamic content to be added to commands at compile time.</p> <p>Inline expressions are written with the syntax <code>&amp;{}</code>, where the expression itself is written between the curly braces.</p>"},{"location":"zoglin/statements/#function-calls","title":"Function Calls","text":"<p>Inline expressions can contain a function call, which compiles to <code>function &lt;function path&gt;</code></p> Zoglin (.zog)MCFunction (.mcfunction) <pre><code>execute if entity @s[tag=my.tag] run &amp;{bar()}\n</code></pre> <pre><code>execute if entity @s[tag=my.tag] run function example:bar\n</code></pre>"},{"location":"zoglin/statements/#compile-time-variables-functions","title":"Compile-time Variables / Functions","text":"<p>Inline expressions can contain a compile time variable or function call, the value of which compiles to their run-time equivalents.</p> Zoglin (.zog)MCFunction (.mcfunction) <pre><code>&amp;a = 123\nscoreboard players set $foo example.foo value &amp;{&amp;a}\n</code></pre> <pre><code>scoreboard players set $foo example.foo value 123\n</code></pre> <p>Alternately, these values can be written directly in to commands without requiring inline expression syntax.</p> Zoglin (.zog)MCFunction (.mcfunction) <pre><code>&amp;b = \"Hello, World!\"\ntellraw @a \"&amp;b\"\n</code></pre> <pre><code>tellraw @a \"Hello, World!\"\n</code></pre>"},{"location":"zoglin/variables/","title":"Variables","text":"<p>Variables are used to store data in Zoglin. There are two primary types of variables: Scoreboard variables and Storage variables. (There are other types: See Function Arguments for macro variables, and Compile Time for comptime variables.)</p> <p>As the names suggest, Scoreboard variables store data in scoreboards, and Storage variable store data in data storages. The type of a variable is defined by a prefix to the variable name.</p> <pre><code># No prefix, Storage variable\nstorage = 10\n# `$` prefix, Scoreboard variable\n$scoreboard = 20\n</code></pre> <p>Variables can be assigned to, using the <code>=</code> operators. Variables do not need to be initialised beforehand. Variables may be assigned to using their full resource location, or just by a name. If just the name is provided, the variable is namespaced to the containing function.</p> Zoglin (.zog)MCFunction (.mcfunction) main.zog<pre><code>namespace example\n\nmodule foo {\n  fn bar() {\n    # Full path is example:foo/bar baz\n    baz = \"Hello, World!\"\n\n    # Full path is $qux example.foo.bar\n    $qux = 123\n\n    # Full path explicitly specified as some:custom/path var\n    some:custom/path/var = 20\n  }\n}\n</code></pre> example:foo/bar<pre><code># Full path is example:foo/bar baz\ndata modify storage example:foo/bar baz set value \"Hello, World!\"\n\n# Full path is $qux example.foo.bar\nscoreboard players set $qux example.foo.bar 123\n\n# Full path explicitly specified as some:custom/path var\ndata modify storage some:custom/path var set value 20\n</code></pre> <p>Variables can be used in expressions, just like they would in other programming languages. They must be prefixed with their type, since <code>var</code> and <code>$var</code> refer to different locations, and likely different data.</p> Note <p>There is no way to perform mathematical operations on data storages, so any time a storage variable is used in an operation, they must first be converted to scoreboards. If you are performing many operations on a piece of data, consider using a scoreboard variable instead.</p> Zoglin (.zog)MCFunction (.mcfunction) main.zog<pre><code>namespace example\n\nfn load() {\n  a = 10\n  $b = a\n  c = a + $b\n}\n</code></pre> example:load<pre><code>data modify storage example:load a set value 10\nexecute store result score $b example.load run data get storage example:load a\nexecute store result score $var_0 zoglin.internal.example.vars run data get storage example:load a\nscoreboard players operation $var_0 zoglin.internal.example.vars += $b example.load\nexecute store result storage example:load c int 1 run scoreboard players get $var_0 zoglin.internal.example.vars\n</code></pre>"}]}